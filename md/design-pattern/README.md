# 设计模式:  可复用面向对象软件的基础  
- 第1章引言
  - [ ] 1.1 什么是设计模式
  - [ ] 1.2 Smalltalk MVC中的设计模式
  - [ ] 1.3 描述设计模式
  - [ ] 1.4 设计模式的编目
  - [ ] 1.5 组织编目
  - [ ] 1.6 设计模式怎样解决设计问题
  - [ ] 1.7 怎样选择设计模式
  - [ ] 1.8 怎样使用设计模式
- 第2章实例研究：设计一个文档编辑器
  - [ ] 2.1 设计问题
  - [ ] 2.2 文档结构
  - [ ] 2.3 格式化
  - [ ] 2.4 修饰用户界面
  - [ ] 2.5 支持多种视感标准
  - [ ] 2.6 支持多种窗口系统
  - [ ] 2.7 用户操作
  - [ ] 2.8 拼写检查和断字处理
- 第3章创建型模式
  - [ ] 3.1 Abstract Factory(抽象工厂)—对象创建型模式
  - [ ] 3.2 Builder(生成器)—对象创建型模式
  - [ ] 3.3 Factory Method(工厂方法)—对象创建型模式
  - [ ] 3.4 Prototype(原型)—对象创建型模式
  - [ ] 3.5 Singleton(单件)—对象创建型模式
  - [ ] 3.6 创建型模式的讨论
- 第4章结构型模式
  - [ ] 4.1 Adapter(适配器)—类对象结构型模式
  - [ ] 4.2 Bridge(桥接)—对象结构型模式
  - [ ] 4.3 Composite(组合)—对象结构型模式
  - [ ] 4.4 Decorator(装饰)—对象结构型模式
  - [ ] 4.5 Facade(外观)—对象结构型模式
  - [ ] 4.6 Flyweight(享元)—对象结构型模式
  - [ ] 4.7 Proxy(代理)—对象结构型模式
  - [ ] 4.8 结构型模式的讨论 
- 第5章行为型模式
  - [ ] 5.1 Chain of
  - [ ] 5.2 Command(命令)—对象行为型模式
  - [ ] 5.3 Interpreter(解释器)—类行为型模式
  - [ ] 5.4 Iterator(迭代器)—对象行为型模式
  - [ ] 5.5  Mediator(中介者)—对象行为型模式
  - [ ] 5.6 Memento(备忘录)—对象行为型模式
  - [ ] 5.7 Observer(观察者)—对象行为型模式
  - [ ] 5.8 State(状态)—对象行为型模式
  - [ ] 5.9 Strategy(策略)—对象行为型模式
  - [ ] 5.10 Template Method(模板方法)—
  - [ ] 5.11 Visitor(访问者)—对象行为型 模式
  - [ ] 5.12 行为型模式的讨论
  - [ ] 5.12.1 封装变化
  - [ ] 5.12.2 对象作为参数
  - [ ] 5.12.3 通信应该被封装还是被分布
  - [ ] 5.12.4 对发送者和接收者解耦
- 第6章结论
  - [ ] 6.1 设计模式将带来什么
  - [ ] 6.2 本书简史
  - [ ] 6.3 模式界
  - [ ] 6.4 邀请参与
  - [ ] 6.5 临别感想

